import fs from "fs";
import path from "path";

import {
    CACHE_FOLDER,
    CacheOptions,
    getCachePath,
    getFromCache,
    getTimestampInSeconds,
    saveToCache,
} from "../src/cache/cacheHandler";

describe("getFromCache", () => {
    // Check if the folder exists
    beforeAll(async (): Promise<void> => {
        await fs.promises.mkdir(CACHE_FOLDER, { recursive: true });
    });

    // Tests that the function returns the cached data if it is not expired
    it("should return the cached data when it is not expired", async (): Promise<void> => {
        const key: string = "testKey";
        const cacheOptions: CacheOptions = {
            folder: CACHE_FOLDER,
            expiry: 60 * 60 * 24 * 7 * 4, // 4 weeks
        };
        const cachePath: string = getCachePath(key, cacheOptions.folder as string);
        const cacheData = {
            timestamp: getTimestampInSeconds(),
            data: "testData",
        };
        await fs.promises.writeFile(cachePath, JSON.stringify(cacheData));

        const result: string | null = await getFromCache<string>(key, cacheOptions);

        expect(result).toBe(cacheData.data);

        // Clean up
        await fs.promises.unlink(cachePath);
    });

    // Tests that the function deletes the expired cache file and returns null if the cache has expired
    it("should delete the expired cache file and return null when the cache has expired", async (): Promise<void> => {
        const key: string = "testKey";
        const cacheOptions: CacheOptions = {
            folder: CACHE_FOLDER,
            expiry: 60, // 60 seconds
        };
        const cachePath: string = getCachePath(key, cacheOptions.folder as string);
        const cacheData = {
            timestamp: getTimestampInSeconds() - 60,
            data: "testData",
        };
        await fs.promises.writeFile(cachePath, JSON.stringify(cacheData));

        const result: string | null = await getFromCache<string>(key, cacheOptions);

        expect(result).toBeNull();
        const cacheFileExists: boolean = await fs.promises
            .access(cachePath)
            .then((): boolean => true)
            .catch((): boolean => false);
        expect(cacheFileExists).toBe(false);
    });
});

// Generated by CodiumAI

describe("saveToCache", () => {
    // Tests that saveToCache saves data to cache with default options
    it("should save data to cache with default options", async () => {
        const key: string = "testKey";
        const data: string = "testData";

        await saveToCache(key, data);

        // Assert
        const cachePath: string = getCachePath(key, CACHE_FOLDER);
        const cacheFileExists: boolean = await fs.promises
            .access(cachePath)
            .then((): boolean => true)
            .catch((): boolean => false);
        expect(cacheFileExists).toBe(true);
    });

    // Tests that saveToCache saves data to cache with custom folder option
    it("should save data to cache with custom folder option", async () => {
        const key: string = "testKey";
        const data: string = "testData";
        const customFolder: string = path.join(CACHE_FOLDER, "custom");

        await saveToCache(key, data, { folder: customFolder });

        const cachePath: string = getCachePath(key, customFolder);
        const cacheFileExists: boolean = await fs.promises
            .access(cachePath)
            .then((): boolean => true)
            .catch((): boolean => false);
        expect(cacheFileExists).toBe(true);
    });
});
